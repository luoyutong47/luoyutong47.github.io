<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小题笔记——走方格</title>
    <link href="/2022/04/22/%E8%B5%B0%E6%96%B9%E6%A0%BC/"/>
    <url>/2022/04/22/%E8%B5%B0%E6%96%B9%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p><mark>keyword：</mark><br>模拟、数学规律</p><p><em>（但是这个题用模拟不对）</em></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>从点$(x_1,y_1)$走到$(x_2,y_2)$点(均是整数)，每步能走一个单位长度，只能沿平行于坐标轴的方向运动，每走一步需要向左或向右旋转90°，求最少需要走多少步。<br>所有坐标满足−10000≤x,y≤10000.</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><img src="/../img/%E8%B5%B0%E6%A0%BC%E5%AD%90.jpg" alt="示例"></p><ul><li>移动过程可以分为两个部分：<ul><li>未到达与C点横平或者竖直的时候：由于每走一步都要拐弯，所以可以等效为直接45&amp;deg走。则走的步数就是B点的横&#x2F;纵坐标-A点的横&#x2F;纵坐标，求绝对值之和cnt。</li><li>到达与C横平或竖直的B点之后： 分类讨论（<strong>举例抓出奇偶性规律</strong>）（假设水平&#x2F;竖直差为d)<ul><li>d为奇数：cnt+&#x3D;2*d-1</li><li>d 为偶数：cnt+&#x3D;2d</li></ul></li></ul></li></ul><p><strong>分类原因</strong>：见错误思路记录</p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br><br>&#123;<br><br>    <span class="hljs-type">int</span> a;<br><br>    <span class="hljs-type">int</span> b;<br><br>&#125; dot1, dot2;<br><br>ll t1, t2, ans, d,first;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>    cin &gt;&gt; dot1.a &gt;&gt; dot1.b &gt;&gt; dot2.a &gt;&gt; dot2.b;<br><br>    t1 = <span class="hljs-built_in">abs</span>(dot1.a - dot2.a);<br><br>    t2 = <span class="hljs-built_in">abs</span>(dot1.b - dot2.b);<br><br>    first = <span class="hljs-built_in">min</span>(t1, t2);<span class="hljs-comment">//横平竖直选一个短的走</span><br><br>    ans = first*<span class="hljs-number">2</span>;<br><br>    d = <span class="hljs-built_in">max</span>(t1, t2) - first;<br><br>    <span class="hljs-comment">//假设平齐了，其实是要减去已经走了的横坐标，但是因为是45°所以直接减first</span><br><br>    <span class="hljs-keyword">if</span>(d%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br><br>        ans += d * <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">else</span><br><br>        ans += d * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h1><p>本来采用了模拟的思路。第一步通过比较出发点和结束点的横纵坐标来确定。如果前一步是上下，则后一次是左右，具体左右根据所在点和结尾点的横坐标大小比较来确定。<br>这貌似没问题，当时也花了很多时间在找原因。其实从例题来看就知道，如果第一步走上，则不是最短的。走到B点会发现没法向右走。<br><strong>即</strong>：当中途达到与结果点相平行或竖直的点处，如果间隔d是奇数，则下一步必须是朝着结果点方向的。而这就要求前一步必须与结果点方向垂直，不能是任意的。按原先的计算方式是可能实现不了这个特殊要求。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>模拟确实是解决很多题的一个方式，但是归纳数学式子往往是更多算法题的思路。</li><li>可以通过将过程分段，设置特殊节点的方式，然后人工走程序的逻辑，来查出错误。（因为分段了，所以点可以拉的远一点，也不怕乱）</li><li>另外，在写笔记的时候弄错了插入图片的相对路径表达。使用..&#x2F;表示返回上一级目录。.&#x2F;表示同级目录。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>小题笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记</title>
    <link href="/2022/04/05/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/05/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>跟随课堂作业进度写的笔记，主要是自己需要用的。旁边有目录。</p><span id="more"></span><h2 id="对列表"><a href="#对列表" class="headerlink" title="对列表"></a>对列表</h2><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>set()函数创建一个无序<strong>不重复</strong>元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</p><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p>add() 方法用于给集合添加元素，<strong>如果添加的元素在集合中已存在，则不执行任何操作</strong>。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><br>x = <span class="hljs-built_in">set</span>()<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(x)&lt;<span class="hljs-number">20</span>:<br>    x.add(randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>))<br>    <span class="hljs-comment">#这样创建的就是没有重复量的了，很方便，不用自己再加判断</span><br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(x))<br><br></code></pre></div></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>删除特定值，且删除的是第一个匹配项</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">aList = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>, <span class="hljs-string">&#x27;zara&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>];<br><br>aList.remove(<span class="hljs-string">&#x27;xyz&#x27;</span>);<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;List : &quot;</span>, aList;<br>aList.remove(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;List : &quot;</span>, aList;<br><br><span class="hljs-comment">#List :  [123, &#x27;zara&#x27;, &#x27;abc&#x27;, &#x27;xyz&#x27;]</span><br><span class="hljs-comment">#List :  [123, &#x27;zara&#x27;, &#x27;xyz&#x27;]</span><br></code></pre></div></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>用于反向列表中元素。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">aList = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>, <span class="hljs-string">&#x27;zara&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>]<br><br>aList.reverse()<span class="hljs-comment">#注意：不可以写成alist=alist.reverse()，这样得到的是返回值None</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;List : &quot;</span>, aList)<br><span class="hljs-comment">#结果：</span><br><span class="hljs-comment">#List :  [&#x27;xyz&#x27;, &#x27;abc&#x27;, &#x27;zara&#x27;, &#x27;xyz&#x27;, 123]</span><br></code></pre></div></td></tr></table></figure><hr><h2 id="对字典"><a href="#对字典" class="headerlink" title="对字典"></a>对字典</h2><h3 id="contains-key"><a href="#contains-key" class="headerlink" title="__contains__(key)"></a>__contains__(key)</h3><p>在判断一个字典dict是否包含某个键值item，可以使用的是if item in dict.keys():。而字典比较大的时候会出现耗时严重的情况，于是改成<strong>if dict.__contains__(item)：</strong>速度会变快很多。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>:<span class="hljs-string">&#x27;coco&#x27;</span>,<span class="hljs-string">&#x27;Sex&#x27;</span>:<span class="hljs-string">&#x27;Female&#x27;</span>&#125;  <span class="hljs-comment"># 定义字典</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dict</span>.__contains__(<span class="hljs-string">&#x27;Name&#x27;</span>))   <span class="hljs-comment"># True</span><br></code></pre></div></td></tr></table></figure><hr><h2 id="itertools-模块"><a href="#itertools-模块" class="headerlink" title="itertools 模块"></a>itertools 模块</h2><h3 id="cycle"><a href="#cycle" class="headerlink" title="cycle()"></a>cycle()</h3><ul><li>函数仅接受一个参数作为输入，可以像列表，字符串，元组等</li><li>该函数返回<strong>迭代器对象类型</strong></li><li>在函数的实现中，返回类型为yield，它在不破坏局部变量的情况下挂起函数执行。由生成中间结果的生成器使用</li><li>它遍历输入自变量中的每个元素并产生它并<strong>重复循环</strong>，<strong>并产生一个无穷大的自变量序列</strong></li></ul><p>相关链接：<a href="https://blog.csdn.net/u013066730/article/details/114278749">【Python】Itertools.cycle()用法及代码示例</a></p><h3 id="compress"><a href="#compress" class="headerlink" title="compress()"></a>compress()</h3><p>此迭代器根据作为其他参数传递的布尔列表值有选择地从传递的容器中选择要打印的值。打印与布尔值true相对应的参数，否则将全部跳过。</p><p>在此，我们为函数提供两个参数。第一个参数将是迭代器，第二个参数将是选择器<code>True/1</code>或者<code>False/0</code>。如果第一个参数的对应选择器是<code>True</code>，则将打印相应的数据，然后我们将得到相应的输出。</p><p>格式：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">compress(<span class="hljs-built_in">iter</span>, selector)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>)<br>y = (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)*<span class="hljs-number">9</span>+(<span class="hljs-number">1</span>,)<span class="hljs-comment">#*9代表着复制九次</span><br><span class="hljs-comment">#y打印出来是(1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1)</span><br><span class="hljs-built_in">list</span>(itertools.compress(x, y)) <br><span class="hljs-comment">#list打印出来是：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</span><br></code></pre></div></td></tr></table></figure><h3 id="groupby（）"><a href="#groupby（）" class="headerlink" title="groupby（）"></a>groupby（）</h3><p>相关链接：<a href="https://blog.csdn.net/qq_38237214/article/details/111597534">itertools中的groupby()的原理及其操作</a></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">group</span>(<span class="hljs-params">v</span>):<br>    <span class="hljs-keyword">if</span> v&gt;<span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;greater than 10&#x27;</span><br>    <span class="hljs-keyword">elif</span> v&lt;<span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;less than 5&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;between 5 and 10&#x27;</span><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>)<br><span class="hljs-comment">#1,4,7,10,13,16,19</span><br>y = itertools.groupby(x, group)     <span class="hljs-comment">#根据函数返回值对序列元素进行分组</span><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> y:<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-built_in">list</span>(v))<br><span class="hljs-comment">#k里面存的是group的返回值</span><br><span class="hljs-comment">#v存的是对应的x</span><br><span class="hljs-comment">#每提取一次，都是对新的值进行一次分类判断</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">结果：</span><br><span class="hljs-string">less than 5 : [1, 4]</span><br><span class="hljs-string">between 5 and 10 : [7, 10]    </span><br><span class="hljs-string">greater than 10 : [13, 16, 19]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><hr><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>指能够被内置函数<code>next</code>调用并不断返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值的对象称为迭代器(<code>Iterator</code>)</p><p>相关链接：[Python内置类型(5)–迭代器类型](<a href="https://www.cnblogs.com/sesshoumaru/p/python-iterator.html#:~:text=Python%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">https://www.cnblogs.com/sesshoumaru/p/python-iterator.html#:~:text=Python内置类型</a> (5)–迭代器类型. 指能够被内置函数 next 调用并不断返回下一个值，直到最后抛出 StopIteration 错误表示无法继续返回下一个值的对象称为迭代器,( Iterator) 其实以上的说法只是侠义上的迭代器的定义，在python中，迭代器还需要实现可迭代接口 ( Iterable )，可迭代接口需要返回的是一个迭代器对象，这样迭代器就能够被 for 语句进行迭代。.)</p><p><strong>可以理解成一个指针</strong></p><p>另外，<code>for</code>循环每执行一次即相当于调用了一次<code>next(iterator)</code>方法，直到捕获到<code>StopIteration</code>异常退出循环。</p><p>写程序理解：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br>x=<span class="hljs-string">&quot;abcdefg&quot;</span><br>y=itertools.cycle(x)<span class="hljs-comment">#返回的应该是一个迭代器类型的</span><br>i=<span class="hljs-number">1</span><br>ch0=<span class="hljs-built_in">next</span>(y)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ch0=&quot;</span>,ch0)<br><span class="hljs-keyword">for</span> ch1 <span class="hljs-keyword">in</span> y:<br>    i+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(ch1,end=<span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-comment">#跳出时，i==11,ch1==d</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n——————&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    ch2=<span class="hljs-built_in">next</span>(y)<br>    <span class="hljs-built_in">print</span>(ch2,end=<span class="hljs-string">&#x27; &#x27;</span>)<br>  <br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">输出：</span><br><span class="hljs-string">ch0= a</span><br><span class="hljs-string">b c d e f g a b c</span><br><span class="hljs-string">——————</span><br><span class="hljs-string">e f g a b c d e f g</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>由以上可以发现，用了next(y)可以这样理解：next是在调用的时候才往下跳，取一个新的值。最初始在第一个值之前，当第一次调用了next的时候就跳到第一个值。next或者for（本质也是next）移动取值了之后的效果是保存的，就像指针移动了之后指向的是操作后的地方。如例子中ch0读了y的第一个值a后，ch1就是从第二个值b开始读了</p><h3 id="创建可迭代对象：iter-函数"><a href="#创建可迭代对象：iter-函数" class="headerlink" title="创建可迭代对象：iter()函数"></a>创建可迭代对象：iter()函数</h3><p>相关链接：<a href="https://blog.csdn.net/weixin_38705903/article/details/102870485">【Python】iter()用途及如何创建一个可迭代的对象_</a></p><p>（注意上面链接关于类型的判断）</p><hr><h2 id="对字符串"><a href="#对字符串" class="headerlink" title="对字符串"></a>对字符串</h2><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.find(<span class="hljs-built_in">str</span>, beg=<span class="hljs-number">0</span>, end=<span class="hljs-built_in">len</span>(string))<br><span class="hljs-comment">#str -- 指定检索的字符串</span><br><span class="hljs-comment">#beg -- 开始索引，默认为0。</span><br><span class="hljs-comment">#end -- 结束索引，默认为字符串的长度。</span><br><br>a=<span class="hljs-string">&#x27;hello,world.&#x27;</span><br><span class="hljs-built_in">print</span> a.find(<span class="hljs-string">&quot;o,&quot;</span>)<br><span class="hljs-comment">#输出：4</span><br><br><span class="hljs-comment">#单纯判断有没有可以不用函数，比如：</span><br>b=<span class="hljs-string">&#x27;abcde&#x27;</span><br><span class="hljs-string">&#x27;ab&#x27;</span> <span class="hljs-keyword">in</span> b<br><span class="hljs-comment">#输出：True</span><br></code></pre></div></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>用于将序列中的元素以指定的字符连接生成一个新的字符串。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;-&quot;</span>;<br>seq = (<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<span class="hljs-comment"># 字符串序列</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">str</span>.join( seq )<br><span class="hljs-comment">#输出是a-b-c</span><br><br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;*&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>))))<span class="hljs-comment">#输出5的阶乘</span><br></code></pre></div></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>用于统计字符串里某个字符或子字符串出现的次数。可选参数为在字符串搜索的开始与结束位置。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.count(sub, start= <span class="hljs-number">0</span>,end=<span class="hljs-built_in">len</span>(string))<br></code></pre></div></td></tr></table></figure><ul><li>sub – 搜索的子字符串</li><li>start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。</li><li>end – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。</li></ul><h3 id="swapcase"><a href="#swapcase" class="headerlink" title="swapcase()"></a>swapcase()</h3><p>将字符串大小写互换</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.swapcase()<br></code></pre></div></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</p><p>(注意，更改的不是原字符串，而是str指向的内容，字符串是不可更改的)</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;this is string example....wow!!! this is really string&quot;</span>;<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;was&quot;</span>);<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;was&quot;</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">#输出：</span><br><span class="hljs-comment">#thwas was string example....wow!!! thwas was really string</span><br><span class="hljs-comment">#thwas was string example....wow!!! thwas is really string</span><br></code></pre></div></td></tr></table></figure><h3 id="endswith"><a href="#endswith" class="headerlink" title="endswith()"></a>endswith()</h3><p>用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。可选参数”start”与”end”为检索字符串的开始与结束位置。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.endswith(suffix[, start[, end]])<br></code></pre></div></td></tr></table></figure><ul><li>suffix – 该参数可以是一个字符串或者是一个元素。</li><li>start – 字符串中的开始位置。</li><li>end – 字符中结束位置。</li></ul><p>可用于<strong>判断文件名后缀</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">fileName=<span class="hljs-string">&#x27;hello.jpg&#x27;</span><br>fileEnd=<span class="hljs-string">&#x27;jpg&#x27;</span><br><span class="hljs-built_in">print</span>(fileName.endswith(fileEnd))<br><span class="hljs-comment">#True</span><br></code></pre></div></td></tr></table></figure><p>相对应的是startswith()</p><h3 id="re-split"><a href="#re-split" class="headerlink" title="re.split()"></a>re.split()</h3><p>一次加入多个分割条件</p><p>形式：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>re.split(pattern, string[, maxsplit=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>])<br></code></pre></div></td></tr></table></figure><p>pattern:匹配的字符串(可使用正则表达式）<br>string:需要切分的字符串<br>maxsplit:分隔次数，默认为0(即不限次数)<br>flags:标志位，用于控制正则表达式的匹配方式，比如：是否区分大小写</p><p><strong>正则表达式</strong>表见链接：<a href="https://blog.csdn.net/qq_31672701/article/details/100711585">正则表达式</a></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>s=<span class="hljs-string">&#x27;abc,  abc,  defg,  dds&#x27;</span><br>re.split(<span class="hljs-string">&#x27;\W+&#x27;</span>,s) <span class="hljs-comment"># \W匹配任何非单词字符</span><br><span class="hljs-comment">#结果：[&#x27;abc&#x27;, &#x27;abc&#x27;, &#x27;defg&#x27;, &#x27;dds&#x27;]</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>s=<span class="hljs-string">&#x27;abc,  abc,  defg,  dds&#x27;</span><br>re.split(<span class="hljs-string">&#x27;(\W+)&#x27;</span>,s) <span class="hljs-comment"># 如果加上了括号，返回值会包括剔除的部分</span><br><span class="hljs-comment">#结果：[&#x27;abc&#x27;, &#x27;,  &#x27;, &#x27;abc&#x27;, &#x27;,  &#x27;, &#x27;defg&#x27;, &#x27;,  &#x27;, &#x27;dds&#x27;]</span><br></code></pre></div></td></tr></table></figure><h3 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit()"></a>isdigit()</h3><p>判断一个字符串是否只含有数字&#x2F;一个字符是否为数字,是则返回True，不是则返回False</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">password=<span class="hljs-string">&#x27;hello1234HHH&#x27;</span><br><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> password: <span class="hljs-comment">#这样就可以用每个字母了</span><br>    <span class="hljs-keyword">if</span> ch.isdigit():<br>        digitN=<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>同类的还有：**isupper()<strong>判断是否是大写，</strong>islower()**判断是否是小写</p><hr><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="math-sqrt"><a href="#math-sqrt" class="headerlink" title="math.sqrt()"></a>math.sqrt()</h3><p>其实就是开根号，但是要import math，并且使用的时候不能单独一个sqrt</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>对参数序列中元素进行累积。</p><p>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的<strong>函数 <strong>function（有两个参数）先对集合中的第 1、2 个元素</strong>进行操作</strong>，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce <span class="hljs-comment">#需要导入模块functools</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) :            <span class="hljs-comment"># 两数相加</span><br>    <span class="hljs-keyword">return</span> x + y<br>sum1 = reduce(add, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])   <span class="hljs-comment"># 计算列表和：1+2+3+4+5</span><br>sum2 = reduce(<span class="hljs-keyword">lambda</span> x, y: x+y, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])  <span class="hljs-comment"># 使用 lambda 匿名函数</span><br><span class="hljs-built_in">print</span>(sum1)<br><span class="hljs-built_in">print</span>(sum2)<br><span class="hljs-comment">#结果：15\n15</span><br></code></pre></div></td></tr></table></figure><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp()"></a>cmp()</h3><p>cmp(x,y) 函数用于比较2个对象，如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1。</p><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda()"></a>lambda()</h3><p>有点像#define一个格式的感觉</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> arguments : expression<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = <span class="hljs-keyword">lambda</span> a : a + <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(x(<span class="hljs-number">7</span>))<br><span class="hljs-comment"># 17</span><br></code></pre></div></td></tr></table></figure><hr><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h3 id="isintance"><a href="#isintance" class="headerlink" title="isintance()"></a>isintance()</h3><p>isinstance() 函数来判断一个对象是否是一个已知的类型，类似 **type()**。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">object</span>, classinfo)<br></code></pre></div></td></tr></table></figure><ul><li>object – 实例对象。</li><li>classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。</li></ul><blockquote><p>isinstance() 与 type() 区别：</p><ul><li><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p></li><li><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p></li></ul><p>如果要判断两个类型是否相同推荐使用 isinstance()。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-built_in">isinstance</span>(A(), A)    <span class="hljs-comment"># returns True</span><br><span class="hljs-built_in">type</span>(A()) == A        <span class="hljs-comment"># returns True</span><br><span class="hljs-built_in">isinstance</span>(B(), A)    <span class="hljs-comment"># returns True</span><br><span class="hljs-built_in">type</span>(B()) == A        <span class="hljs-comment"># returns Fals</span><br></code></pre></div></td></tr></table></figure><h3 id="bool"><a href="#bool" class="headerlink" title="bool()"></a>bool()</h3><p>bool()函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。</p><p>bool 是 int 的子类。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>))<br><span class="hljs-comment">#True</span><br></code></pre></div></td></tr></table></figure><p>扩展：<strong>布尔类型</strong></p><p>Python 中布尔值使用常量 True 和 False 来表示。</p><p>1、在数值上下文环境中，True被当作 1，False 被当作0</p><p>2、其他类型值转换 bool 值时除了 ‘’、””、’’’’’’、””””””、0、()、[]、{}、None、0.0、0L、0.0+0.0j、False*为 False外，其他都为 True</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
